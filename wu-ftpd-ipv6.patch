diff -Nur wu-ftpd-2.6.2.orig/README.v6 wu-ftpd-2.6.2/README.v6
--- wu-ftpd-2.6.2.orig/README.v6	Thu Jan  1 01:00:00 1970
+++ wu-ftpd-2.6.2/README.v6	Tue Jan 22 20:53:08 2002
@@ -0,0 +1,31 @@
+IPv6-capable wu-ftpd
+Jun-ichiro Itoh, KAME Project <itojun@kame.net>
+$Id$
+
+
+This patch kit contains a patch to enable wu-ftpd to handle
+both IPv4 and IPv6 connections.
+
+SUPPORTED EXTENSIONS
+====================
+LPSV, LPRT, EPSV, EPRT are supported.
+"EPSV ALL" is accepted but ignored.
+
+
+HOW TO BUILD BINARY
+===================
+Normally, binary can easily be built with "configure" script.
+Basically,
+	% sh configure --enable-ipv6
+	% su
+	# make install
+should work fine.
+
+Currently, the following platforms are supported:
+	KAME:	http://www.kame.net
+	Linux:	http://www.linux.org
+
+Updated to 2.6.1 by Arkadiusz Miskiewicz <misiek@pld.org.pl>, PLD GNU/Linux.
+Updated by Masaaki NORO <noro@flab.fujitsu.co.jp>,
+	   Hideaki YOSHIFUJI <yoshfuji@ecei.tohoku.ac.jp> and
+	   Yuji Sekiya <sekiya@v6.linux.or.jp>
diff -Nur wu-ftpd-2.6.2.orig/config.h.in wu-ftpd-2.6.2/config.h.in
--- wu-ftpd-2.6.2.orig/config.h.in	Thu Nov 29 18:10:57 2001
+++ wu-ftpd-2.6.2/config.h.in	Tue Jan 22 20:53:37 2002
@@ -353,3 +353,19 @@
  * line FTP client users.
  */
 #undef NLST_SHOWS_DIRS
+
+
+/*
+ * IPv6
+ */
+#undef HAVE_SOCKADDR_LEN
+
+/* Define this if you have ss_family field in sockaddr_storage */
+#undef HAVE_SS_FAMILY_IN_SS
+
+/* Define this if you have __ss_family field in sockaddr_storage */
+#undef HAVE___SS_FAMILY_IN_SS
+
+/* Define this if you have declaration of struct sockaddr_storage */
+#undef HAVE_STRUCT_SOCKADDR_STORAGE
+
diff -Nur wu-ftpd-2.6.2.orig/configure.in wu-ftpd-2.6.2/configure.in
--- wu-ftpd-2.6.2.orig/configure.in	Thu Nov 29 18:10:58 2001
+++ wu-ftpd-2.6.2/configure.in	Tue Jan 22 20:53:08 2002
@@ -702,6 +702,210 @@
 AC_SUBST(STRCASECMP)
 AC_SUBST(STRNCASECMP)
 
+dnl === part for IPv6 support ===
+AC_MSG_CHECKING([whether to enable ipv6])
+AC_ARG_ENABLE(ipv6,
+[  --enable-ipv6           Enable ipv6 (with ipv4) support
+  --disable-ipv6          Disable ipv6 support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       ipv6=no
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       AC_DEFINE(ENABLE_IPV6)
+       ipv6=yes
+       ;;
+  esac ],
+
+  AC_TRY_RUN([ /* AF_INET6 avalable check */
+#include <sys/types.h>
+#include <sys/socket.h>
+main()
+{
+ if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+   exit(1);
+ else
+   exit(0);
+}
+],
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(ENABLE_IPV6)
+  ipv6=yes,
+  AC_MSG_RESULT(no)
+  ipv6=no,
+  AC_MSG_RESULT(no)
+  ipv6=no
+))
+
+ipv6type=unknown
+ipv6lib=none
+
+if test "$ipv6" = "yes"; then
+        AC_MSG_CHECKING([IPv6 stack type])
+        for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
+                case $i in
+                inria)
+                        dnl http://www.kame.net/
+                        AC_EGREP_CPP(%%%yes%%%, [dnl
+#include <netinet/in.h>
+#ifdef IPV6_INRIA_VERSION
+%%%yes%%%
+#endif],
+                                [ipv6type=$i;
+                                CFLAGS="-DINET6 $CPPFLAGS"])
+                        ;;
+                kame)
+                        dnl http://www.kame.net/
+                        AC_EGREP_CPP(%%%yes%%%, [dnl
+#include <netinet/in.h>
+#ifdef __KAME__
+%%%yes%%%
+#endif],
+                                [ipv6type=$i;
+                                ipv6lib=inet6;
+                                ipv6libdir=/usr/local/v6/lib;
+                                CFLAGS="-DINET6 $CPPFLAGS"])
+                        ;;
+                linux-glibc)
+                        dnl http://www.v6.linux.or.jp/
+                        AC_EGREP_CPP(%%%yes%%%, [dnl
+#include <features.h>
+#if defined(__GLIBC__) && __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1
+%%%yes%%%
+#endif],
+                                [ipv6type=$i;
+				default_enable_ipv4in6=yes
+                                CFLAGS="-DINET6 -DLINUX $CFLAGS"])
+                        ;;
+                linux-inet6)
+                        dnl http://www.v6.linux.or.jp/
+                        if test -d /usr/inet6; then
+                                ipv6type=$i
+                                ipv6lib=inet6
+                                ipv6libdir=/usr/inet6/lib
+				default_enable_ipv4in6=yes
+                                CFLAGS="-DINET6 -DLINUX -I/usr/inet6/include $CFLAGS"
+                        fi
+                        ;;
+                toshiba)
+                        AC_EGREP_CPP(%%%yes%%%, [dnl
+#include <sys/param.h>
+#ifdef _TOSHIBA_INET6
+%%%yes%%%
+#endif],
+                                [ipv6type=$i;
+                                ipv6lib=inet6;
+                                ipv6libdir=/usr/local/v6/lib;
+                                CFLAGS="-DINET6 $CFLAGS"])
+                        ;;
+                v6d)
+                        AC_EGREP_CPP(%%%yes%%%, [dnl
+#include </usr/local/v6/include/sys/v6config.h>
+#ifdef __V6D__
+%%%yes%%%
+#endif],
+                                [ipv6type=$i;
+                                ipv6lib=v6;
+                                ipv6libdir=/usr/local/v6/lib;
+                                CFLAGS="-I/usr/local/v6/include $CFLAGS"])
+                        ;;
+                zeta)
+                        AC_EGREP_CPP(%%%yes%%%, [dnl
+#include <sys/param.h>
+#ifdef _ZETA_MINAMI_INET6
+yes
+#endif],
+                                [ipv6type=$i;
+                                ipv6lib=inet6;
+                                ipv6libdir=/usr/local/v6/lib;
+                                CFLAGS="-DINET6 $CFLAGS"])
+                        ;;
+dnl             solaris7)
+dnl                     ipv6type=$i;
+dnl                     CFLAGS="-DINET6 $CFLAGS"
+dnl                     ;;
+                esac
+                if test "$ipv6type" != "unknown"; then
+                        break
+                fi
+        done
+        AC_MSG_RESULT($ipv6type)
+fi
+
+if test "$ipv6" = "yes" -a "$ipv6lib" != "none"; then
+        if test -d $ipv6libdir -a -f $ipv6libdir/lib$ipv6lib.a; then
+                LIBS="-L$ipv6libdir -l$ipv6lib $LIBS"
+        else
+                echo 'Fatal: no $ipv6lib library found.  cannot continue.'
+                echo "You need to fetch lib$ipv6lib.a from appropriate"
+                echo 'ipv6 kit and compile beforehand.'
+                exit 1
+        fi
+fi
+
+dnl checking for sa_len;
+dnl  the following check says 'yes' if your system has __libc_sa_len
+dnl  AC_EGREP_HEADER(sa_len, sys/socket.h,
+dnl    [ AC_DEFINE(HAVE_SOCKADDR_LEN) AC_MSG_RESULT(yes)], AC_MSG_RESULT(no))
+AC_MSG_CHECKING([whether struct sockaddr has sa_len])
+AC_TRY_COMPILE([
+#include <sys/types.h>
+#include <sys/socket.h>
+],[
+struct sockaddr sa;
+int i = sa.sa_len;
+],
+[AC_MSG_RESULT(yes)
+ AC_DEFINE(HAVE_SOCKADDR_LEN)],
+AC_MSG_RESULT(no))
+
+AC_CACHE_CHECK([for struct sockaddr_storage], ac_cv_have_struct_sockaddr_storage, [
+       AC_TRY_COMPILE(
+               [
+#include <sys/types.h>
+#include <sys/socket.h>
+               ],
+               [ struct sockaddr_storage s; ],
+               [ ac_cv_have_struct_sockaddr_storage="yes" ],
+               [ ac_cv_have_struct_sockaddr_storage="no" ]
+       )
+])
+if test "x$ac_cv_have_struct_sockaddr_storage" = "xyes" ; then
+       AC_DEFINE(HAVE_STRUCT_SOCKADDR_STORAGE)
+fi
+AC_CACHE_CHECK([for ss_family field in struct sockaddr_storage],
+               ac_cv_have_ss_family_in_struct_ss, [
+       AC_TRY_COMPILE(
+               [
+#include <sys/types.h>
+#include <sys/socket.h>
+               ],
+               [ struct sockaddr_storage s; s.ss_family = 1; ],
+               [ ac_cv_have_ss_family_in_struct_ss="yes" ],
+               [ ac_cv_have_ss_family_in_struct_ss="no" ],
+       )
+])
+if test "x$ac_cv_have_ss_family_in_struct_ss" = "xyes" ; then
+       AC_DEFINE(HAVE_SS_FAMILY_IN_SS)
+fi
+
+
+AC_CACHE_CHECK([for __ss_family field in struct sockaddr_storage],
+               ac_cv_have___ss_family_in_struct_ss, [
+       AC_TRY_COMPILE(
+               [
+#include <sys/types.h>
+#include <sys/socket.h>
+               ],
+               [ struct sockaddr_storage s; s.__ss_family = 1; ],
+               [ ac_cv_have___ss_family_in_struct_ss="yes" ],
+               [ ac_cv_have___ss_family_in_struct_ss="no" ]
+       )
+])
+if test "x$ac_cv_have___ss_family_in_struct_ss" = "xyes" ; then
+       AC_DEFINE(HAVE___SS_FAMILY_IN_SS)
+fi
 
 dnl ===========================================================================
 dnl Get the --enable, --disable, --with, --without stuff into the config files
diff -Nur wu-ftpd-2.6.2.orig/src/authenticate.c wu-ftpd-2.6.2/src/authenticate.c
--- wu-ftpd-2.6.2.orig/src/authenticate.c	Sat Jul  1 20:17:38 2000
+++ wu-ftpd-2.6.2/src/authenticate.c	Tue Jan 22 20:53:08 2002
@@ -27,6 +27,8 @@
 #include "config.h"
 #include <stdio.h>
 #include <string.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
 #include "support/authuser.h"
 #include "authenticate.h"
 #include "proto.h"
@@ -49,7 +51,7 @@
 {
     char *user;
 #if USE_A_RFC931
-    unsigned long in;
+    struct sockaddr_storage in;
     unsigned short local, remote;
 #endif /* USE_A_RFC931 */
 
@@ -60,10 +62,10 @@
 #if USE_A_RFC931
     if (disable_rfc931 || (timeout_rfc931 == 0))
 	user = "*";
-    else if (auth_fd(0, &in, &local, &remote) == -1)
+    else if (auth_fd(0, (struct sockaddr *)&in, &local, &remote) == -1)
 	user = "?";		/* getpeername/getsockname failure */
     else {
-	if (!(user = auth_tcpuser(in, local, remote)))
+	if (!(user = auth_tcpuser((struct sockaddr *)&in, local, remote)))
 	    user = "*";		/* remote host doesn't support RFC 931 */
 	else
 	    authenticated |= A_RFC931;
diff -Nur wu-ftpd-2.6.2.orig/src/ftpcmd.y wu-ftpd-2.6.2/src/ftpcmd.y
--- wu-ftpd-2.6.2.orig/src/ftpcmd.y	Thu Nov 29 18:01:38 2001
+++ wu-ftpd-2.6.2/src/ftpcmd.y	Tue Jan 22 20:53:08 2002
@@ -54,17 +54,24 @@
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h>
+#include <netdb.h>
 #include "extensions.h"
 #include "pathnames.h"
 #include "proto.h"
 
+#include "sa_len.h"
+
+#ifndef MAXHOSTNAMELEN
+#define MAXHOSTNAMELEN 64  /* may be too big */
+#endif
+
 extern int dolreplies;
 #ifndef INTERNAL_LS
 extern char ls_long[50];
 extern char ls_short[50];
 #endif
-extern struct sockaddr_in data_dest;
-extern struct sockaddr_in his_addr;	/* added.  _H */
+extern struct sockaddr_storage data_dest;
+extern struct sockaddr_storage his_addr;	/* added.  _H */
 extern int logged_in;
 extern struct passwd *pw;
 extern int anonymous;
@@ -127,7 +134,7 @@
 #endif
 
 static unsigned short cliport = 0;
-static struct in_addr cliaddr;
+static struct sockaddr_storage cliaddr;
 static int cmd_type;
 static int cmd_form;
 static int cmd_bytesz;
@@ -162,6 +169,7 @@
 %token
     A   B   C   E   F   I
     L   N   P   R   S   T
+    ALL
 
     SP  CRLF    COMMA   STRING  NUMBER
 
@@ -173,6 +181,8 @@
     STAT    HELP    NOOP    MKD     RMD     PWD
     CDUP    STOU    SMNT    SYST    SIZE    MDTM
 
+    LPRT    LPSV    EPRT    EPSV
+
     UMASK   IDLE    CHMOD   GROUP   GPASS   NEWER
     MINFO   INDEX   EXEC    ALIAS   CDPATH  GROUPS
     CHECKMETHOD     CHECKSUM
@@ -187,6 +197,7 @@
 %type <String>  STRING password pathname pathstring username method
 %type <Number>  NUMBER byte_size check_login form_code 
 %type <Number>  struct_code mode_code octal_number
+%type <String>  ALL
 
 %start  cmd_list
 
@@ -221,36 +232,209 @@
 	}
     | PORT check_login SP host_port CRLF
 	=	{
+#ifdef INET6
+	    char hname[INET6_ADDRSTRLEN];
+#else
+	    char hname[MAXHOSTNAMELEN];
+#endif
+            char *port_host;
+	    char pbuf[NI_MAXSERV];
 	    if (log_commands)
 		syslog(LOG_INFO, "PORT");
 /* H* port fix, part B: admonish the twit.
    Also require login before PORT works */
 	    if ($2) {
-#ifndef DISABLE_PORT
-		if (((cliaddr.s_addr == his_addr.sin_addr.s_addr)
-		     || (port_allowed(inet_ntoa(cliaddr))))
-		    && (ntohs(cliport) > 1023)) {
+#ifndef DISABLE_PORT /*noro*/
+                if (cliaddr.ss_family == AF_INET){
+		getnameinfo((struct sockaddr *)&cliaddr,
+				SA_LEN((struct sockaddr *)&cliaddr),
+				NULL, 0, pbuf, sizeof(pbuf), NI_NUMERICSERV);
+		    port_host=(char *)&pbuf;
+                }
+		if (cliaddr.ss_family == AF_INET &&
+				((((struct sockaddr_in *)&cliaddr)->sin_addr.s_addr == ((struct sockaddr_in *)&his_addr)->sin_addr.s_addr) ||
+				 (port_allowed(port_host))) &&
+				ntohs(((struct sockaddr_in *)&cliaddr)->sin_port) > 1023) {
 		    usedefault = 0;
 		    if (pdata >= 0) {
 			(void) close(pdata);
 			pdata = -1;
 		    }
-		    data_dest.sin_family = AF_INET;
-		    data_dest.sin_addr = cliaddr;
-		    data_dest.sin_port = cliport;
+		    memcpy(&data_dest, &cliaddr, sizeof(data_dest));
 		    reply(200, "PORT command successful.");
 		}
 		else {
-#endif
 		    memset(&data_dest, 0, sizeof(data_dest));
-		    syslog(LOG_WARNING, "refused PORT %s,%d from %s",
-			   inet_ntoa(cliaddr), ntohs(cliport), remoteident);
+#endif
+		    {
+		    char port_buf[NI_MAXSERV];
+		    if (getnameinfo((struct sockaddr *)&cliaddr,
+			    SA_LEN((struct sockaddr *)&cliaddr),
+			    hname, sizeof(hname), port_buf, sizeof(port_buf),
+			    NI_NUMERICHOST|NI_NUMERICSERV))
+		    {
+			    strcpy(hname, "???");
+			    strcpy(port_buf, "???");
+		    }
+
+		    syslog(LOG_WARNING, "refused PORT %s,%s from %s",
+			   hname, port_buf, remoteident);
 		    reply(500, "Illegal PORT Command");
+		    }
 #ifndef DISABLE_PORT
 		}
+	    }
+	}
+    |   LPRT check_login SP host_long_port4 CRLF
+	= {
+#ifdef INET6
+	  char hname[INET6_ADDRSTRLEN];
+#else
+	  char hname[MAXHOSTNAMELEN];
+#endif
+          if (log_commands) syslog(LOG_INFO, "LPRT");
+	  usedefault = 0;
+	  if (pdata >= 0) {
+		  (void) close(pdata);
+		  pdata = -1;
+	  }
+            if ($2) {
+		    if (cliaddr.ss_family == AF_INET) {
+		    memcpy(&data_dest, &cliaddr, sizeof(data_dest));
+		    reply(200, "LPRT command successful.");
+	    } else {
+		    char port_buf[NI_MAXSERV];
+		    memset(&data_dest, 0, sizeof(data_dest));
+		    if (getnameinfo((struct sockaddr *)&cliaddr,
+			    SA_LEN((struct sockaddr *)&cliaddr),
+			    hname, sizeof(hname), port_buf, sizeof(port_buf),
+			    NI_NUMERICHOST|NI_NUMERICSERV)) {
+			    strcpy(hname, "???");
+			    strcpy(port_buf, "???");
+		    }
+		    syslog (LOG_WARNING, "refused LPRT %s,%s from %s",
+				    hname, port_buf, remotehost);
+		    reply(500, "Illegal LPRT Command");
+	    }
 #endif
 	    }
 	}
+    |   LPRT check_login SP host_long_port6 CRLF
+         = {
+#ifdef INET6
+          char hname[INET6_ADDRSTRLEN];
+
+            if (log_commands) syslog(LOG_INFO, "LPRT");
+            usedefault = 0;
+            if (pdata >= 0) {
+                (void) close(pdata);
+                pdata = -1;
+            }
+          if ($2) {
+              if (cliaddr.ss_family == AF_INET6) {
+		  memcpy(&data_dest, &cliaddr, sizeof(data_dest));
+                  reply(200, "LPRT command successful.");
+              } else {
+		  char port_buf[NI_MAXSERV];
+                  memset(&data_dest, 0, sizeof(data_dest));
+		  if (getnameinfo((struct sockaddr *)&cliaddr, SA_LEN((struct sockaddr *)&cliaddr),
+                      hname, sizeof(hname), port_buf, sizeof(port_buf),
+		      NI_NUMERICHOST|NI_NUMERICSERV)) {
+                      strcpy(hname, "???");
+		      strcpy(port_buf, "???");
+                   }
+                   syslog (LOG_WARNING, "refused LPRT %s,%s from %s",
+                           hname, port_buf, remotehost);
+                   reply(500, "Illegal LPRT Command");
+              }
+          }
+#else
+          reply(500, "IPv6 LPRT not supported.");
+#endif
+        }
+    |   EPRT SP STRING CRLF
+        = {
+#ifdef INET6
+          char *tmp = NULL;
+          char *result[3];
+          char *p, *q;
+          char delim;
+          struct addrinfo hints;
+          struct addrinfo *res;
+          int i;
+
+            if (log_commands) syslog(LOG_INFO, "EPRT");
+            usedefault = 0;
+            if (pdata >= 0) {
+                (void) close(pdata);
+                pdata = -1;
+            }
+
+          /*XXX checks for login */
+
+          tmp = strdup($3);
+          if (!tmp) {
+              fatal("not enough core.");
+              /*NOTREACHED*/
+          }
+          p = tmp;
+          delim = p[0];
+          p++;
+          memset(result, 0, sizeof(result));
+          for (i = 0; i < 3; i++) {
+              q = strchr(p, delim);
+              if (!q || *q != delim) {
+      parsefail:
+                  reply(500, "Invalid argument, rejected.");
+                  if (tmp)
+                      free(tmp);
+                  usedefault = 1;
+                  goto eprt_done;
+              }
+              *q++ = '\0';
+              result[i] = p;
+              p = q;
+          }
+
+          /* some more sanity check */
+          p = result[0];
+          while (*p) {
+              if (!isdigit(*p))
+                  goto parsefail;
+              p++;
+          }
+          p = result[2];
+          while (*p) {
+              if (!isdigit(*p))
+                  goto parsefail;
+              p++;
+          }
+
+          memset(&hints, 0, sizeof(hints));
+          if (atoi(result[0]) == 1)
+              hints.ai_family = PF_INET;
+          if (atoi(result[0]) == 2)
+              hints.ai_family = PF_INET6;
+          else
+              hints.ai_family = PF_UNSPEC;    /*XXX*/
+          hints.ai_socktype = SOCK_STREAM;
+          if (getaddrinfo(result[1], result[2], &hints, &res))
+              goto parsefail;
+          memcpy(&data_dest, res->ai_addr, res->ai_addrlen);
+          free(tmp);
+          tmp = NULL;
+
+          if (data_dest.ss_family != AF_INET
+          && data_dest.ss_family != AF_INET6) {
+              reply(500, "unsupported address family.");
+              usedefault = 1;
+          } else
+              reply(200, "EPRT command successful.");
+      eprt_done:;
+#else
+          reply(500, "EPRT not supported.");
+#endif
+        }
     | PASV check_login CRLF
 	=	{
 /* Require login for PASV, too.  This actually fixes a bug -- telnet to an
@@ -260,6 +444,48 @@
 	    if ($2)
 #if (defined (DISABLE_PORT) || !defined (DISABLE_PASV))
 		passive();
+        }
+    |   LPSV check_login CRLF
+        = {
+/* Require login for PASV, too.  This actually fixes a bug -- telnet to an
+   unfixed wu-ftpd and type PASV first off, and it crashes! */
+            if (log_commands) syslog(LOG_INFO, "LPSV");
+	    if ($2)
+		long_passive("LPSV", PF_UNSPEC);
+        }
+    | EPSV check_login SP NUMBER CRLF
+	= {
+	    if ($2) {
+		int pf;
+		switch ($4) {
+		case 1:
+		    pf = PF_INET;
+		    break;
+		case 2:
+		    pf = PF_INET6;
+		    break;
+		default:
+		    pf = -1;	/*junk value*/
+		    break;
+		}
+		long_passive("EPSV", pf);
+	    }
+	}
+    | EPSV check_login SP ALL CRLF
+	= {
+	    if ($2) {
+		reply(200,
+		    "EPSV ALL command successful.");
+		/* further processing required */
+	    }
+	}
+    |   EPSV check_login CRLF
+        = {
+/* Require login for PASV, too.  This actually fixes a bug -- telnet to an
+   unfixed wu-ftpd and type PASV first off, and it crashes! */
+            if (log_commands) syslog(LOG_INFO, "EPSV");
+	    if ($2)
+		long_passive("EPSV", PF_UNSPEC);
 #else
 		reply(425, "Cannot open passive connection");
 #endif
@@ -1003,19 +1229,73 @@
 
 host_port: NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER
 	=	{
-	    register char *a, *p;
+	    register char *a;
+
 
-	    a = (char *) &cliaddr;
+	    memset(&cliaddr, 0, sizeof(cliaddr));
+	    cliaddr.ss_family = AF_INET;
+#ifdef HAVE_SOCKADDR_LEN
+	    ((struct sockaddr_in *)&cliaddr)->sin_len = sizeof(struct sockaddr_in);
+#endif
+            a = (char *)&((struct sockaddr_in *)&cliaddr)->sin_addr;
 	    a[0] = $1;
 	    a[1] = $3;
 	    a[2] = $5;
 	    a[3] = $7;
-	    p = (char *) &cliport;
-	    p[0] = $9;
-	    p[1] = $11;
+	    ((struct sockaddr_in *)&cliaddr)->sin_port = ntohs((($9 & 0xff) << 8) | $11);
 	}
     ;
 
+host_long_port4:  NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER
+        = {
+            register char *a;
+
+          memset(&cliaddr, 0, sizeof(cliaddr));
+          if ($1 == 4 && $3 == 4 && $13 == 2) {
+              cliaddr.ss_family = AF_INET;
+#ifdef HAVE_SOCKADDR_LEN
+	      ((struct sockaddr_in *)&cliaddr)->sin_len = sizeof(struct sockaddr_in);
+#endif
+              a = (char *)&((struct sockaddr_in *)&cliaddr)->sin_addr;
+              a[0] = $5; a[1] = $7; a[2] = $9; a[3] = $11;
+	      ((struct sockaddr_in *)&cliaddr)->sin_port = ntohs((($13 & 0xff) << 8) | $15);
+          } else {
+              /* ??? */
+          }
+        }
+    ;
+
+host_long_port6:  NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER COMMA NUMBER COMMA
+      NUMBER COMMA NUMBER COMMA NUMBER
+        = {
+            register char *a;
+
+          memset(&cliaddr, 0, sizeof(cliaddr));
+#ifdef INET6
+          if ($1 == 6 && $3 == 16 && $37 == 2) {
+              cliaddr.ss_family = AF_INET6;
+#ifdef HAVE_SOCKADDR_LEN
+              ((struct sockaddr_in6 *)&cliaddr)->sin6_len = sizeof(struct sockaddr_in6);
+#endif
+              a = (char *)&((struct sockaddr_in6 *)&cliaddr)->sin6_addr;
+              a[0] = $5; a[1] = $7; a[2] = $9; a[3] = $11;
+              a[4] = $13; a[5] = $15; a[6] = $17; a[7] = $19;
+              a[8] = $21; a[9] = $23; a[10] = $25; a[11] = $27;
+              a[12] = $29; a[13] = $31; a[14] = $33; a[15] = $35;
+              ((struct sockaddr_in6 *)&cliaddr)->sin6_port = ntohs((($39 & 0xff) << 8) | $41);
+          } else {
+              /* ??? */
+          }
+#endif
+        }
+    ;
+
 form_code: N
 	=	{
 	    $$ = FORM_N;
@@ -1295,6 +1575,10 @@
     {"STOU", STOU, STR1, 1, "<sp> file-name"},
     {"SIZE", SIZE, OSTR, 1, "<sp> path-name"},
     {"MDTM", MDTM, OSTR, 1, "<sp> path-name"},
+    {"LPRT", LPRT, ARGS, 1, "<sp> af, hal, h1, h2, .., pal, p1, p2, ..." },
+    {"LPSV", LPSV, ARGS, 1, "(set server in passive mode)" },
+    {"EPRT", EPRT, STR1, 1, "<sp> |af|addr|port|" },
+    {"EPSV", EPSV, ARGS, 1, "[<sp> af|ALL]" },
     {NULL, 0, 0, 0, 0}
 };
 
@@ -1650,6 +1934,11 @@
 		cbuf[cpos] = c;
 		return (NUMBER);
 	    }
+	    if (strncasecmp(&cbuf[cpos], "ALL", 3) == 0
+			    && !isalnum(cbuf[cpos + 3])) {
+		    cpos += 3;
+		    return ALL;
+	    }
 	    switch (cbuf[cpos++]) {
 
 	    case '\n':
diff -Nur wu-ftpd-2.6.2.orig/src/ftpd.c wu-ftpd-2.6.2/src/ftpd.c
--- wu-ftpd-2.6.2.orig/src/ftpd.c	Thu Nov 29 17:56:11 2001
+++ wu-ftpd-2.6.2/src/ftpd.c	Tue Jan 22 21:02:56 2002
@@ -164,6 +164,8 @@
 #include <sys/resource.h>
 #endif
 
+#include "sa_len.h"
+
 #if defined(USE_LONGJMP)
 #define wu_longjmp(x, y)	longjmp((x), (y))
 #define wu_setjmp(x)		setjmp(x)
@@ -228,12 +230,17 @@
 extern off_t restart_point;
 extern int yyerrorcalled;
 
-struct sockaddr_in ctrl_addr;
-struct sockaddr_in data_source;
-struct sockaddr_in data_dest;
-struct sockaddr_in his_addr;
-struct sockaddr_in pasv_addr;
-struct sockaddr_in vect_addr;
+struct sockaddr_storage ctrl_addr;
+struct sockaddr_storage data_source;
+struct sockaddr_storage data_dest;
+struct sockaddr_storage his_addr;
+struct sockaddr_storage pasv_addr;
+struct sockaddr_storage vect_addr;
+#if defined(INET6)
+u_short protocol_family=AF_UNSPEC;
+#else
+u_short protocol_family=AF_INET;
+#endif
 int route_vectored = 0;
 int passive_port_min = -1;
 int passive_port_max = -1;
@@ -356,9 +363,15 @@
 char defhome[] = "/";
 #endif
 char tmpline[7];
+#ifndef INET6
 char hostname[MAXHOSTNAMELEN];
 char remotehost[MAXHOSTNAMELEN];
 char remoteaddr[MAXHOSTNAMELEN];
+#else
+char hostname[INET6_ADDRSTRLEN];
+char remotehost[INET6_ADDRSTRLEN];
+char remoteaddr[INET6_ADDRSTRLEN];
+#endif
 char *remoteident = "[nowhere yet]";
 
 /* log failures         27-apr-93 ehk/bm */
@@ -424,7 +437,7 @@
 #endif
 
 #ifdef HAVE_LIBRESOLV
-int initialize_dns(struct sockaddr_in *remote_socket);
+int initialize_dns(struct sockaddr_storage *remote_socket);
 int check_reverse_dns(void);
 int check_matching_dns(void);
 #endif
@@ -461,6 +474,8 @@
 int ultrix_check_pass(char *passwd, char *xpasswd);
 #endif
 
+int family = AF_INET;
+
 #ifdef USE_PAM
 #if defined(ULTRIX_AUTH) || defined(SECUREOSF) || defined(KERBEROS) || defined(SKEY) || defined (OPIE) || defined (BSD_AUTH)
 #error No other auth methods are allowed with PAM.
@@ -504,7 +519,7 @@
 #else
 int send_data(FILE *, FILE *, off_t);
 #endif
-void dolog(struct sockaddr_in *);
+void dolog(struct sockaddr *);
 void dologout(int);
 void perror_reply(int, char *);
 int denieduid(uid_t);
@@ -581,7 +596,9 @@
 #endif
     extern int optopt;
     extern char *optarg;
-    struct hostent *shp;
+    struct addrinfo hints;
+    struct addrinfo *res;
+    int error;
     struct aclmember *entry;
 #ifdef VIRTUAL
 #if defined(UNIXWARE) || defined(AIX)
@@ -589,8 +606,9 @@
 #else
     int virtual_len;
 #endif
-    struct sockaddr_in *virtual_ptr;
-    struct sockaddr_in virtual_addr;
+    struct sockaddr_storage *virtual_ptr;
+    struct sockaddr_storage virtual_addr;
+    char ntop_buf[INET6_ADDRSTRLEN];
 #endif
 #ifndef DAEMON
     struct servent *serv;
@@ -633,23 +651,51 @@
 	exit(1);
 #endif
     }
+#if defined(INET6) && defined(LINUX)
+    if (his_addr.ss_family == AF_INET6){
+	if (IN6_IS_ADDR_V4MAPPED(&his_addr.su_sin6.sin6_addr)){
+	    struct in_addr addr;
+	    unsigned short port;
+	    memcpy(&addr, 12 + (char *)&his_addr.su_sin6.sin6_addr, sizeof(addr));
+	    port = his_addr.su_sin6.sin6_port;
+	    memset(&his_addr, 0, sizeof(his_addr));
+	    his_addr.su_sin.sin_family = AF_INET;
+	    memcpy(&his_addr.su_sin.sin_addr, &addr, sizeof(addr));
+	    his_addr.su_sin.sin_port = port;
+            protocol_family=AF_INET;
+        } else {
+            protocol_family=AF_INET6;
+        }
+    };
+#endif
+
 #ifdef IPTOS_LOWDELAY
-    tos = IPTOS_LOWDELAY;
-    if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof(int)) < 0)
-	    syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
+    if (ctrl_addr.ss_family == AF_INET) {
+	    tos = IPTOS_LOWDELAY;
+	    if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof(int)) < 0)
+		    syslog(LOG_WARNING, "setsockopt (IP_TOS): %m");
+    }
 #endif
 
     serv = getservbyname("ftp-data", "tcp");
     if (serv != NULL)
 	data_source.sin_port = serv->s_port;
     else
-	data_source.sin_port = htons(ntohs(ctrl_addr.sin_port) - 1);
+	data_source.su_port = htons(ntohs(ctrl_addr.su_sin.sin_port) - 1);
 #endif /* DAEMON */
 
 #ifndef DAEMON
-    while ((c = getopt(argc, argv, ":aAvdlLiIoP:qQr:t:T:u:wVWX")) != -1) {
+    while ((c = getopt(argc, argv, ":aAvdlLiIoP:qQr:t:T:u:wVWX"
+#ifdef INET6
+				    "46"
+#endif
+				    )) != -1) {
 #else /* DAEMON */
-    while ((c = getopt(argc, argv, ":aAvdlLiIop:P:qQr:sSt:T:u:VwWX")) != -1) {
+    while ((c = getopt(argc, argv, ":aAvdlLiIop:P:qQr:sSt:T:u:VwWX"
+#ifdef INET6
+				    "46"
+#endif
+				    )) != -1) {
 #endif /* DAEMON */
 	switch (c) {
 
@@ -706,7 +752,8 @@
 	    break;
 
 	case 'P':
-	    data_source.sin_port = htons(atoi(optarg));
+	    // FIXME
+	    // data_source.su_port = htons(atoi(optarg)); /* XXX */
 	    break;
 
 #ifdef DAEMON
@@ -752,10 +799,20 @@
 	    print_copyright();
 	    exit(0);
 	    /* NOTREACHED */
-	case 'w':
-	    wtmp_logging = 1;
+#ifdef INET6
+	case '4':
+	    family = AF_INET;
 	    break;
 
+	case '6':
+	    family = AF_INET6;
+	    break;
+#endif /* INET6 */
+	    
+	case 'w':
+            wtmp_logging = 1;
+            break;
+
 	case 'W':
 	    wtmp_logging = 0;
 	    break;
@@ -991,6 +1048,32 @@
 	exit(1);
 #endif
     }
+    {
+	    char buf[254];
+/*
+	    printf("PROTOCOL = %d\n", ctrl_addr.ss_family); 
+	    printf("ADDRESS = %s\n", inet_ntoa( ctrl_addr.su_sin.sin_addr ));
+	    inet_ntop( AF_INET6, &ctrl_addr.su_sin.sin_addr, buf ,sizeof(struct in6_addr) + 256);
+	    printf("ADDRESS = %s\n", buf);
+*/
+    }
+#if defined(INET6) && defined(LINUX)
+    if (his_addr.ss_family == AF_INET6){
+	if (IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)&his_addr)->sin6_addr)){
+	    struct in_addr addr;
+	    unsigned short port;
+	    memcpy(&addr, 12 + &((struct sockaddr_in6 *)&his_addr)->sin6_addr, sizeof(addr));
+	    port = ((struct sockaddr_in6 *)&his_addr)->sin6_port;
+	    memset(&his_addr, 0, sizeof(his_addr));
+	    ((struct sockaddr_in *)&his_addr)->sin_family = AF_INET;
+	    memcpy(&((struct sockaddr_in *)&his_addr)->sin_addr, &addr, sizeof(addr));
+	    ((struct sockaddr_in *)&his_addr)->sin_port = port;
+	    protocol_family=AF_INET;
+        } else {
+	    protocol_family=AF_INET6;
+        }
+    }
+#endif
 #ifdef IPTOS_LOWDELAY
     tos = IPTOS_LOWDELAY;
     if (setsockopt(0, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof(int)) < 0)
@@ -1000,7 +1083,10 @@
 	if (setsockopt(0, SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) < 0)
 	    syslog(LOG_ERR, "setsockopt SO_KEEPALIVE %m");
 
-    data_source.sin_port = htons(ntohs(ctrl_addr.sin_port) - 1);
+    if (ctrl_addr.ss_family == AF_INET6)
+	    ((struct sockaddr_in6 *)&data_source)->sin6_port = htons(ntohs(((struct sockaddr_in6 *)&ctrl_addr)->sin6_port) - 1);
+    else
+	    ((struct sockaddr_in *)&data_source)->sin_port = htons(ntohs(((struct sockaddr_in *)&ctrl_addr)->sin_port) - 1);
 #endif /* DAEMON */
 
     /* Try to handle urgent data inline */
@@ -1034,7 +1120,7 @@
     initialize_dns(&his_addr);
 #endif
 
-    dolog(&his_addr);
+    dolog((struct sockaddr *)&his_addr);
     /* Set up default state */
     data = -1;
     type = TYPE_A;
@@ -1056,10 +1142,15 @@
 	(void) gethostname(hostname, sizeof(hostname));
 #endif
 /* set the FQDN here */
-	shp = gethostbyname(hostname);
-	if (shp != NULL) {
-	    (void) strncpy(hostname, shp->h_name, sizeof(hostname));
-	    hostname[sizeof(hostname) - 1] = '\0';
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = PF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_CANONNAME;
+	error = getaddrinfo(hostname, NULL, &hints, &res);
+	if (!error && res && res->ai_canonname) {
+		syslog(LOG_DEBUG, "got canonname %s", res->ai_canonname);
+		(void) strncpy(hostname, res->ai_canonname, sizeof(hostname));
+		hostname[sizeof(hostname)-1]='\0';
 	}
     }
     route_vectored = routevector();
@@ -1100,14 +1191,18 @@
 	virtual_hostname[0] = '\0';
 	virtual_address[0] = '\0';
 	virtual_len = sizeof(virtual_addr);
-	if (getsockname(0, (struct sockaddr *) &virtual_addr, &virtual_len) == 0) {
-	    virtual_ptr = (struct sockaddr_in *) &virtual_addr;
-	    strcpy(virtual_address, inet_ntoa(virtual_ptr->sin_addr));
-	    shp = gethostbyaddr((char *) &virtual_ptr->sin_addr, sizeof(struct in_addr), AF_INET);
-	    if (shp != NULL) {
-		(void) strncpy(virtual_hostname, shp->h_name, sizeof(virtual_hostname));
-		virtual_hostname[sizeof(virtual_hostname) - 1] = '\0';
-	    }
+	if (getsockname(0, (struct sockaddr *) &virtual_addr, &virtual_len) == 0
+#ifndef INET6
+			&& virtual_addr.ss_family == AF_INET
+#endif
+			) {
+	    virtual_ptr = &virtual_addr;
+	    getnameinfo((struct sockaddr *)virtual_ptr, virtual_len,
+			    virtual_address, sizeof(virtual_address),
+			    NULL, 0, NI_NUMERICHOST);
+	    getnameinfo((struct sockaddr *)virtual_ptr, virtual_len,
+			    virtual_hostname, sizeof(virtual_hostname),
+			    NULL, 0, 0);
 	    entry = (struct aclmember *) NULL;
 	    while (getaclentry("virtual", &entry)) {
 		if (!ARG0 || !ARG1 || !ARG2)
@@ -4678,7 +4773,7 @@
 	return (fdopen(data, mode));
     delay_signaling();		/* we can't allow any signals while euid==0: kinch */
     (void) seteuid((uid_t) 0);
-    s = socket(AF_INET, SOCK_STREAM, 0);
+    s = socket(ctrl_addr.ss_family, SOCK_STREAM, 0);
     if (s < 0)
 	goto bad;
     if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
@@ -4690,15 +4785,23 @@
 	(void) setsockopt(s, SOL_SOCKET, (*mode == 'w' ? SO_SNDBUF : SO_RCVBUF),
 			  (char *) &TCPwindowsize, sizeof(TCPwindowsize));
     /* anchor socket to avoid multi-homing problems */
-    data_source.sin_family = AF_INET;
-    data_source.sin_addr = ctrl_addr.sin_addr;
+    data_source = ctrl_addr;
+    
+    if (data_source.ss_family == AF_INET6)
+	    ((struct sockaddr_in6 *)&data_source)->sin6_port = 0;
+    else
+	    ((struct sockaddr_in *)&data_source)->sin_port = 0;
 
 #if defined(VIRTUAL) && defined(CANT_BIND)	/* can't bind to virtual address */
-    data_source.sin_addr.s_addr = htonl(INADDR_ANY);
+    if (data_source.ss_family == AF_INET6)
+	    ((struct sockaddr_in6 *)&data_source)->sin6_addr = in6addr_any;
+    else
+	    ((struct sockaddr_in *)&data_source)->sin_addr.s_addr = htonl(INADDR_ANY);
 #endif
     for (tries = 1;; tries++) {
 	if (bind(s, (struct sockaddr *) &data_source,
-		 sizeof(data_source)) >= 0)
+		 SA_LEN((struct sockaddr *)&data_source)
+	    ) >= 0)
 	    break;
 	if (errno != EADDRINUSE || tries > 10)
 	    goto bad;
@@ -4719,6 +4822,7 @@
     (void) seteuid((uid_t) pw->pw_uid);
     enable_signaling();		/* we can allow signals once again: kinch */
 
+    if (ctrl_addr.ss_family == AF_INET) {
 #ifdef IPTOS_THROUGHPUT
     on = IPTOS_THROUGHPUT;
     if (setsockopt(s, IPPROTO_IP, IP_TOS, (char *) &on, sizeof(int)) < 0)
@@ -4735,7 +4839,7 @@
     if (setsockopt(s, IPPROTO_TCP, TCP_NOPUSH, (char *) &on, sizeof on) < 0)
 	syslog(LOG_WARNING, "setsockopt (TCP_NOPUSH): %m");
 #endif
-
+    }
     return (fdopen(s, mode));
   bad:
     on = errno;			/* hold errno for return */
@@ -4756,6 +4860,11 @@
 #ifdef IPTOS_LOWDELAY
     int tos;
 #endif
+#ifdef INET6
+    char ntop_buf[INET6_ADDRSTRLEN];
+#else
+    char ntop_buf[MAXHOSTNAMELEN];
+#endif
 #ifdef THROUGHPUT
     int bps;
     double bpsmult;
@@ -4768,8 +4877,13 @@
     else
 	(void) strcpy(sizebuf, "");
     if (pdata >= 0) {
-	struct sockaddr_in from;
+	struct sockaddr_storage from;
+#ifndef INET6
 	char dataaddr[MAXHOSTNAMELEN];
+#else
+	char dataaddr[INET6_ADDRSTRLEN];
+	char remoteaddr_v6[INET6_ADDRSTRLEN];
+#endif
 #if defined(UNIXWARE) || defined(AIX)
 	size_t fromlen = sizeof(from);
 #else
@@ -4821,14 +4935,30 @@
 	(void) close(pdata);
 	pdata = s;
 #ifdef IPTOS_LOWDELAY
+	if (from.ss_family == AF_INET) {
 	tos = IPTOS_LOWDELAY;
 	(void) setsockopt(s, IPPROTO_IP, IP_TOS, (char *) &tos,
 			  sizeof(int));
-
+	}
 #endif
-	(void) strncpy(dataaddr, inet_ntoa(from.sin_addr), sizeof(dataaddr));
+		if (getnameinfo((struct sockaddr *)&from, fromlen,
+					dataaddr, sizeof(dataaddr), NULL, 0,
+					NI_NUMERICHOST) != 0) {
+			strncpy(dataaddr, "invalid", sizeof(dataaddr));
+		}
 	if (!pasv_allowed(dataaddr))
+#ifdef INET6
+#ifdef LINUX
+	    if ((strcasecmp(dataaddr, remoteaddr) != 0) && 
+		(IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)&from)->sin6_addr) && (strlen(dataaddr) > 7) &&
+		 (strcasecmp(7+dataaddr,remoteaddr)))
+		) {
+#else
 	    if (strcasecmp(dataaddr, remoteaddr) != 0) {
+#endif
+#else
+	    if (strcasecmp(dataaddr, remoteaddr) != 0) {
+#endif
 		/* 
 		 * This will log when data connection comes from an address different
 		 * than the control connection.
@@ -4868,23 +4998,47 @@
     }
     if (usedefault)
 	data_dest = his_addr;
-    if (data_dest.sin_port == 0) {
+    if ((data_dest.ss_family == AF_INET6 && ((struct sockaddr_in6 *)&data_dest)->sin6_port == 0) ||
+	    (data_dest.ss_family == AF_INET && ((struct sockaddr_in *)&data_dest)->sin_port == 0)) {
 	reply(500, "Can't build data connection: no PORT specified");
 	return (NULL);
     }
     usedefault = 1;
     file = getdatasock(mode);
     if (file == NULL) {
-	reply(425, "Can't create data socket (%s,%d): %s.",
-	      inet_ntoa(data_source.sin_addr),
-	      ntohs(data_source.sin_port), strerror(errno));
+	    char pbuf[NI_MAXSERV];
+	    if (getnameinfo((struct sockaddr *)&data_source,
+				    SA_LEN((struct sockaddr *)&data_source),
+				    ntop_buf, sizeof(ntop_buf), pbuf, sizeof(pbuf),
+				    NI_NUMERICHOST|NI_NUMERICSERV) != 0) {
+		    strncpy(ntop_buf, "???", sizeof(ntop_buf));
+		    strncpy(pbuf, "???", sizeof(pbuf));
+	    }
+	reply(425, "Can't create data socket (%s,%s): %s.",
+		    ntop_buf, pbuf, strerror(errno));
 	return (NULL);
     }
     data = fileno(file);
     (void) signal(SIGALRM, alarm_signal);
     alarm(timeout_connect);
+
+#if defined(INET6) && defined(LINUX)
+    if ((data_dest.ss_family==AF_INET) && (ctrl_addr.ss_family==AF_INET6)){
+	struct in_addr addr;
+	unsigned int port;
+	memcpy(&addr, &((struct sockaddr_in *)&data_dest)->sin_addr, sizeof(addr));
+	port = ((struct sockaddr_in *)&data_dest)->sin_port;
+	memset(&data_dest, 0, sizeof(data_dest));
+	((struct sockaddr_in6 *)&data_dest)->sin6_family=AF_INET6;
+	((struct sockaddr_in6 *)&data_dest)->sin6_addr.s6_addr16[5] = 0xffff;
+	memcpy(&((struct sockaddr_in6 *)&data_dest)->sin6_addr.s6_addr32[3], &addr,
+			sizeof(((struct sockaddr_in6 *)&data_dest)->sin6_addr.s6_addr32[3]));
+	((struct sockaddr_in6 *)&data_dest)->sin6_port = port;
+    }
+#endif
+
     while (connect(data, (struct sockaddr *) &data_dest,
-		   sizeof(data_dest)) < 0) {
+	    SA_LEN((struct sockaddr *)&data_dest)) < 0) {
 	alarm(0);
 	if ((errno == EADDRINUSE || errno == EINTR) && retry < swaitmax) {
 	    sleep((unsigned) swaitint);
@@ -5328,16 +5482,26 @@
 
 void statcmd(void)
 {
-    struct sockaddr_in *sin;
+    struct sockaddr_storage *su;
     u_char *a, *p;
+#ifdef INET6
+    char ntop_buf[INET6_ADDRSTRLEN];
+#else
+    char ntop_buf[MAXHOSTNAMELEN];
+#endif
 
     lreply(211, "%s FTP server status:", hostname);
     lreply(0, "     %s", version);
-    if (!isdigit(remotehost[0]))
-	lreply(0, "     Connected to %s (%s)", remotehost,
-	       inet_ntoa(his_addr.sin_addr));
+    ntop_buf[0] = '\0';
+    if (getnameinfo((struct sockaddr *)&his_addr,
+			    SA_LEN((struct sockaddr *)&his_addr),
+			    ntop_buf, sizeof(ntop_buf), NULL, 0, NI_NUMERICHOST) != 0) {
+	    strncpy(ntop_buf, "???", sizeof(ntop_buf));
+    }
+    if (strcmp(remotehost, ntop_buf) == 0)
+	    lreply(0, "     Connected to %s", remotehost);
     else
-	lreply(0, "     Connected to %s", remotehost);
+	    lreply(0, "     Connected to %s (%s)", remotehost, ntop_buf);
 
     if (logged_in) {
 	if (anonymous)
@@ -5367,17 +5531,90 @@
 	lreply(0, "     Data connection open");
     else if (pdata != -1 || usedefault == 0) {
 	if (usedefault == 0)
-	    sin = &data_dest;
+	    su = (struct sockaddr_storage *)&data_dest;
 	else if (route_vectored)
-	    sin = &vect_addr;
+	    su = (struct sockaddr_storage *)&vect_addr;
 	else
-	    sin = &pasv_addr;
-	a = (u_char *) & sin->sin_addr;
-	p = (u_char *) & sin->sin_port;
+	    su = (struct sockaddr_storage *)&pasv_addr;
 #define UC(b) (((int) b) & 0xff)
-	lreply(0, "     %s (%d,%d,%d,%d,%d,%d)",
-	       usedefault == 0 ? "PORT" : "in Passive mode",
-	       UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
+	/* PORT/PASV */
+        if (su->ss_family == AF_INET) {
+                a = (u_char *) & ((struct sockaddr_in *)su)->sin_addr;
+                p = (u_char *) & ((struct sockaddr_in *)su)->sin_port;
+                lreply(0, "     %s (%d,%d,%d,%d,%d,%d)",
+                                usedefault == 0 ? "PORT" : "PASV",
+                                UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
+
+        }
+
+#ifdef INET6
+	/* LPRT/LPSV */
+	{
+		int alen, af, i;
+		char replybuf[1024];
+		char *p;
+
+		switch (su->ss_family) {
+			case AF_INET:
+				a = (u_char *) & ((struct sockaddr_in *)su)->sin_addr;
+				p = (u_char *) & ((struct sockaddr_in *)su)->sin_port;
+				alen = sizeof(((struct sockaddr_in *)su)->sin_addr);
+				af = 4;
+				break;
+			case AF_INET6:
+				a = (u_char *) & ((struct sockaddr_in6 *)su)->sin6_addr;
+				p = (u_char *) & ((struct sockaddr_in6 *)su)->sin6_port;
+				alen = sizeof(((struct sockaddr_in6 *)su)->sin6_addr);
+				af = 6;
+				break;
+			default:
+				af = 0;
+				break;
+		}
+		if (af) {
+			p = replybuf;
+			sprintf(p, "     %s (%d,%d,",
+					usedefault == 0 ? "LPRT" : "LPSV", af, alen);
+			while (*p)
+				p++;
+			for (i = 0; i < alen; i++) {
+				sprintf(p, "%d,", UC(a[i]));
+				while (*p)
+					p++;
+			}
+			sprintf(p, "%d,%d,%d)", 2, UC(p[0]), UC(p[1]));
+			lreply(0, replybuf);
+		}
+	}
+	
+	/* EPRT/EPSV */
+	{
+		int af;
+
+		switch (su->ss_family) {
+			case AF_INET:
+				af = 1;
+				break;
+			case AF_INET6:
+				af = 2;
+				break;
+			default:
+				af = 0;
+				break;
+		}
+		if (af) {
+			char pbuf[NI_MAXSERV];
+			if (getnameinfo((struct sockaddr *)su,
+					SA_LEN((struct sockaddr *)su),
+					ntop_buf, sizeof(ntop_buf), pbuf, sizeof(pbuf),
+					NI_NUMERICHOST|NI_NUMERICSERV) == 0) {
+				lreply(0, "     %s (|%d|%s|%s)",
+						usedefault == 0 ? "EPRT" : "EPSV", af,
+						ntop_buf, pbuf);
+			}
+		}
+	}
+#endif
 #undef UC
     }
     else
@@ -5963,60 +6200,25 @@
     }
 }
 
-void dolog(struct sockaddr_in *sin)
+void dolog(struct sockaddr *sa)
 {
 #ifndef NO_DNS
-    struct hostent *hp;
-    char *blah;
+    int error, error2;
 
-#ifdef	DNS_TRYAGAIN
-    int num_dns_tries = 0;
-    /*
-     * 27-Apr-93    EHK/BM
-     * far away connections might take some time to get their IP address
-     * resolved. That's why we try again -- maybe our DNS cache has the
-     * PTR-RR now. This code is sloppy. Far better is to check what the
-     * resolver returned so that in case of error, there's no need to
-     * try again.
-     */
-  dns_again:
-    hp = gethostbyaddr((char *) &sin->sin_addr,
-		       sizeof(struct in_addr), AF_INET);
-
-    if (!hp && ++num_dns_tries <= 1) {
-	sleep(3);
-	goto dns_again;		/* try DNS lookup once more     */
-    }
-#else
-    hp = gethostbyaddr((char *) &sin->sin_addr, sizeof(struct in_addr), AF_INET);
-#endif
-
-    blah = inet_ntoa(sin->sin_addr);
-
-    (void) strncpy(remoteaddr, blah, sizeof(remoteaddr));
-
-    if (!strcasecmp(remoteaddr, "0.0.0.0")) {
-	nameserved = 1;
-	strncpy(remotehost, "localhost", sizeof(remotehost));
-    }
-    else {
-	if (hp) {
-	    nameserved = 1;
-	    (void) strncpy(remotehost, hp->h_name, sizeof(remotehost));
-	}
-	else {
-	    nameserved = 0;
-	    (void) strncpy(remotehost, remoteaddr, sizeof(remotehost));
-	}
-    }
-#else
-    char *blah;
-
-    blah = inet_ntoa(sin->sin_addr);
-    (void) strncpy(remoteaddr, blah, sizeof(remoteaddr));
+    error = getnameinfo(sa, SA_LEN((struct sockaddr*)sa), remotehost, sizeof(remotehost), NULL,
+		    0, 0);
+    error2 = getnameinfo(sa, SA_LEN((struct sockaddr*)sa), remoteaddr, sizeof(remoteaddr), NULL, 
+		    0, NI_NUMERICHOST);
+    remoteaddr[sizeof(remoteaddr)-1] = '\0';
+    nameserved = (!error && !error2 && strncmp(remoteaddr,remotehost,sizeof(remotehost)) != 0) ? 1 : 0;
+#else /* ifndef NO_DNS */
+    error2 = getnameinfo(sa, SA_LEN((struct sockaddr*)sa), remoteaddr,
+		    sizeof(remoteaddr), NULL, 0, NI_NUMERICHOST);
+    remoteaddr[sizeof(remoteaddr)-1] = '\0';
+    if (!error2)
+	    strncpy(remotehost, remoteaddr, sizeof(remotehost);
     nameserved = 0;
-    (void) strncpy(remotehost, remoteaddr, sizeof(remotehost));
-#endif
+#endif /* NO_DNS */
 
     remotehost[sizeof(remotehost) - 1] = '\0';
     sprintf(proctitle, "%s: connected", remotehost);
@@ -6146,6 +6348,9 @@
     int bind_error;
     int on = 1;
     register char *p, *a;
+    struct sockaddr_storage *su;
+    char hbuf[NI_MAXHOST];
+    unsigned short int ptm;
 
 /* H* fix: if we already *have* a passive socket, close it first.  Prevents
    a whole variety of entertaining clogging attacks. */
@@ -6169,7 +6374,10 @@
 	(void) setsockopt(pdata, SOL_SOCKET, SO_RCVBUF, (char *) &TCPwindowsize, sizeof(TCPwindowsize));
     }
     pasv_addr = ctrl_addr;
-    pasv_addr.sin_port = 0;
+    if (pasv_addr.ss_family == AF_INET6)
+	    ((struct sockaddr_in6 *)&pasv_addr)->sin6_port = 0;
+    else
+	    ((struct sockaddr_in *)&pasv_addr)->sin_port = 0;
     delay_signaling();		/* we can't allow any signals while euid==0: kinch */
     (void) seteuid((uid_t) 0);	/* XXX: not needed if > 1024 */
 
@@ -6238,8 +6446,11 @@
 		    while (++k < j)
 			port_array[k - 1] = port_array[k];
 		}
-		pasv_addr.sin_port = htons(pasv_port_array[j - 1]);
-		bind_error = bind(pdata, (struct sockaddr *) &pasv_addr, sizeof(pasv_addr));
+		if (pasv_addr.ss_family == AF_INET6)
+		   ((struct sockaddr_in6 *)&pasv_addr)->sin6_port = htons(pasv_port_array [j-1]);
+		else
+		   ((struct sockaddr_in *)&pasv_addr)->sin_port = htons(pasv_port_array [j-1]);
+		bind_error = bind (pdata, (struct sockaddr *)&pasv_addr, SA_LEN((struct sockaddr *)&pasv_addr));
 	    }
 	}
 
@@ -6260,35 +6471,314 @@
 	goto pasv_error;
     if (listen(pdata, 1) < 0)
 	goto pasv_error;
-    usedefault = 1;
+
     if (route_vectored)
-	a = (char *) &vect_addr.sin_addr;
+	su = (struct sockaddr_storage *) &vect_addr;
     else
-	a = (char *) &pasv_addr.sin_addr;
-    p = (char *) &pasv_addr.sin_port;
+	su = (struct sockaddr_storage *) &pasv_addr;
 
-#define UC(b) (((int) b) & 0xff)
+    usedefault = 1;
+
+    if (route_vectored){
+	    if (getnameinfo((struct sockaddr *)&vect_addr, SA_LEN((struct sockaddr *)&vect_addr),
+			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST))
+		    goto pasv_error;
+    } else {
+	    if (getnameinfo((struct sockaddr *)&ctrl_addr, SA_LEN((struct sockaddr *)&ctrl_addr),
+			    hbuf, sizeof(hbuf), NULL, 0, NI_NUMERICHOST))
+		    goto pasv_error;
+    }
+
+    if (su->ss_family == AF_INET6)
+	    ptm = ((struct sockaddr_in6 *)su)->sin6_port;
+    else
+	    ptm = ((struct sockaddr_in *)su)->sin_port;
+
+    p = (char *)&ptm;
 
     if (debug) {
-	char *s = calloc(128 + strlen(remoteident), sizeof(char));
+	char *s = calloc(128 + strlen(remotehost), sizeof(char));
 	if (s) {
-	    int i = ntohs(pasv_addr.sin_port);
-	    sprintf(s, "PASV port %i assigned to %s", i, remoteident);
+	    int i = ntohs(pasv_addr.ss_family == AF_INET ? ((struct sockaddr_in *)&pasv_addr)->sin_port : ((struct sockaddr_in6 *)&pasv_addr)->sin6_port );
+	    sprintf(s, "PASV port %i assigned to %s", i, remotehost);
 	    syslog(LOG_DEBUG, "%s", s);
 	    free(s);
 	}
     }
-    reply(227, "Entering Passive Mode (%d,%d,%d,%d,%d,%d)", UC(a[0]),
-	  UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
+
+#define UC(b) (((int) b) & 0xff)
+    {
+	    int a1,a2,a3,a4;
+	    if( a = strstr( hbuf, "ffff" )){
+		    sscanf( hbuf, "::ffff:%d.%d.%d.%d", &a1,&a2,&a3,&a4 );
+	    } else {
+		    sscanf( hbuf, "%d.%d.%d.%d", &a1,&a2,&a3,&a4 );
+	    }    
+	    reply(227, "Entering Passive Mode (%d,%d,%d,%d,%d,%d)", a1,a2,a3,a4,UC(p[0]),UC(p[1]));
+	    return;
+    }
+#undef UC
+
+
+  pasv_error:
+    (void) close(pdata);
+    pdata = -1;
+if (debug) {
+  char *s = calloc (128+strlen (remotehost), sizeof (char));
+  if (s) {
+    sprintf (s, "PASV port assignment assigned for %s", remotehost);
+    syslog (LOG_DEBUG, s);
+    free (s);
+  }
+}
+    perror_reply(425, "Can't open passive connection");
     return;
+}
+
+/*
+ * Long passive defined in RFC 1639.
+ *    228 Entering Long Passive Mode (af, hal, h1, h2, ..., pal, p1, p2, ...)
+ * Long passive defined in draft-ietf-ftpext-ftp-over-ipv6-02.txt
+ *    229 Entering Extended Passive Mode (|||port|)
+ */
+void
+#ifdef __STDC__
+long_passive(char *cmd, int pf)
+#else
+long_passive(cmd, pf)
+    char *cmd;
+    int pf;
+#endif
+{
+#if defined(UNIXWARE) || defined(AIX)
+    size_t len;
+#else
+    int len;
+#endif
+    int bind_error;
+    char *p, *a;
+    u_short port;
+
+/* H* fix: if we already *have* a passive socket, close it first.  Prevents
+   a whole variety of entertaining clogging attacks. */
+    if (pdata > 0)
+      close (pdata);
+    if (!logged_in) {
+       reply(530, "Login with USER first.");
+       return;
+    }
+
+    if (pf != PF_UNSPEC) {
+      if (ctrl_addr.ss_family != pf) {
+          switch (ctrl_addr.ss_family) {
+          case AF_INET:
+              pf = 1;
+              break;
+          case AF_INET6:
+              pf = 2;
+              break;
+          default:
+              pf = 0;
+              break;
+          }
+          /*
+           * XXX
+           * only EPRT/EPSV ready clients will understand this
+           */
+          if (strcmp(cmd, "EPSV") == 0 && pf) {
+              reply(522, "Network protocol mismatch, "
+                          "use (%d)", pf);
+          } else
+              reply(501, "Network protocol mismatch"); /*XXX*/
+
+          return;
+      }
+    }
+
+    if (TCPwindowsize) {
+        (void) setsockopt(pdata, SOL_SOCKET, SO_SNDBUF, (char *) &TCPwindowsize, sizeof(TCPwindowsize));
+        (void) setsockopt(pdata, SOL_SOCKET, SO_RCVBUF, (char *) &TCPwindowsize, sizeof(TCPwindowsize));
+    }
+    pdata = socket(ctrl_addr.ss_family, SOCK_STREAM, 0);
+    if (pdata < 0) {
+        perror_reply(425, "Can't open passive connection");
+        return;
+    }
+    pasv_addr = ctrl_addr;
+    if (pasv_addr.ss_family == AF_INET6)
+	  ((struct sockaddr_in6 *)&pasv_addr)->sin6_port = 0;
+    else
+	  ((struct sockaddr_in *)&pasv_addr)->sin_port = 0;
+    delay_signaling(); /* we can't allow any signals while euid==0: kinch */
+    (void) seteuid((uid_t) 0);                /* XXX: not needed if > 1024 */
+
+checkports();
+
+if (passive_port_min ==  -1) {
+    passive_port_max = 65534;
+    passive_port_min = 1024;
+}
+
+ {
+    int *port_array;
+    int *pasv_port_array;
+    int i;
+    int j;
+    int k;
+
+    if (passive_port_max < passive_port_min) {
+        (void) seteuid((uid_t) pw->pw_uid);
+        enable_signaling(); /* we can allow signals once again: kinch */
+        goto pasv_error;
+    }
+
+    i = passive_port_max - passive_port_min + 1;
+
+    port_array = calloc (i, sizeof (int));
+    if (port_array == NULL) {
+        (void) seteuid((uid_t) pw->pw_uid);
+        enable_signaling(); /* we can allow signals once again: kinch */
+        goto pasv_error;
+    }
+
+    pasv_port_array = calloc (i, sizeof (int));
+    if (pasv_port_array == NULL) {
+        free (port_array);
+        (void) seteuid((uid_t) pw->pw_uid);
+        enable_signaling(); /* we can allow signals once again: kinch */
+        goto pasv_error;
+    }
+
+    do {
+        --i;
+        port_array [i] = passive_port_min + i;
+    } while (i > 0);
+
+    srand (time (NULL));
+
+/*
+    i = passive_port_max - passive_port_min + 1;
+    do {
+        --i;
+        j = (int) (((1.0 + i) * rand()) / (RAND_MAX + 1.0));
+        pasv_port_array [i] = port_array [j];
+        while (++j <= i)
+            port_array [j-1] = port_array [j];
+    } while (i > 0);
+*/
+
+    bind_error = -1;
+    errno = EADDRINUSE;
+    for (i = 3; (bind_error < 0) && (errno == EADDRINUSE) && (i > 0); i--) {
+        for (j = passive_port_max - passive_port_min + 1; (bind_error < 0) &&
+(errno == EADDRINUSE) && (j > 0); j--) {
+            if (i == 3) {
+              k = (int) ((1.0 * j * rand()) / (RAND_MAX + 1.0));
+              pasv_port_array [j-1] = port_array [k];
+              while (++k < j)
+                  port_array [k-1] = port_array [k];
+          }
+          if (pasv_addr.ss_family == AF_INET6)
+                  ((struct sockaddr_in6 *)&pasv_addr)->sin6_port = htons (pasv_port_array [j-1]);
+          else
+                  ((struct sockaddr_in *)&pasv_addr)->sin_port = htons (pasv_port_array [j-1]);
+          bind_error = bind (pdata, (struct sockaddr *)&pasv_addr, SA_LEN((struct sockaddr *)&pasv_addr));
+        }
+    }
+    free (pasv_port_array);
+    free (port_array);
+
+    if ( bind_error < 0 ) {
+        (void) seteuid((uid_t) pw->pw_uid);
+        enable_signaling(); /* we can allow signals once again: kinch */
+        goto pasv_error;
+    }
+ }
+
+     (void) seteuid((uid_t) pw->pw_uid);
+    enable_signaling(); /* we can allow signals once again: kinch */
+    len = SA_LEN((struct sockaddr *)&pasv_addr);
+    if (getsockname(pdata, (struct sockaddr *) &pasv_addr, &len) < 0)
+        goto pasv_error;
+    if (listen(pdata, 1) < 0)
+        goto pasv_error;
+    usedefault = 1;
+    if (pasv_addr.ss_family == AF_INET6)
+      port = ((struct sockaddr_in6 *)&pasv_addr)->sin6_port;
+    else
+      port = ((struct sockaddr_in *)&pasv_addr)->sin_port;
+
+#define UC(b) (((int) b) & 0xff)
+
+    if (strcmp(cmd, "LPSV") == 0) {
+
+if (debug) {
+  char *s = calloc (128+strlen (remotehost), sizeof (char));
+  if (s) {
+    int i = ntohs (port);
+    sprintf (s, "LPSV port %i assigned to %s", i, remotehost);
+    syslog (LOG_DEBUG, s);
+    free (s);
+  }
+}
+      switch (pasv_addr.ss_family) {
+      case AF_INET:
+          if (route_vectored)
+              a = (char *) &((struct sockaddr_in *)&vect_addr)->sin_addr;
+          else
+              a = (char *) &((struct sockaddr_in *)&pasv_addr)->sin_addr;
+          p = (char *) &((struct sockaddr_in *)&pasv_addr)->sin_port;
+          reply(227, "Entering Passive Mode (%d,%d,%d,%d,%d,%d)", UC(a[0]),
+                UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
+          return;
+#ifdef INET6
+      case AF_INET6:
+          if (route_vectored)
+              a = (char *) &((struct sockaddr_in6 *)&vect_addr)->sin6_addr;
+          else
+              a = (char *) &((struct sockaddr_in6 *)&pasv_addr)->sin6_addr;
+          p = (char *) &((struct sockaddr_in6 *)&pasv_addr)->sin6_port;
+          reply(228, "Entering Long Passive Mode (%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)", 6, 16,
+              UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]),
+              UC(a[4]), UC(a[5]), UC(a[6]), UC(a[7]),
+              UC(a[8]), UC(a[9]), UC(a[10]), UC(a[11]),
+              UC(a[12]), UC(a[13]), UC(a[14]), UC(a[15]),
+              2, UC(p[0]), UC(p[1]));
+          return;
+#endif
+      }
+#undef UC
+    } else if (strcmp(cmd, "EPSV") == 0) {
+      switch (pasv_addr.ss_family) {
+      case AF_INET:
+#ifdef INET6
+      case AF_INET6:
+#endif
+if (debug) {
+  char *s = calloc (128+strlen (remotehost), sizeof (char));
+  if (s) {
+    int i = ntohs (port);
+    sprintf (s, "EPSV port %i assigned to %s", i, remotehost);
+    syslog (LOG_DEBUG, s);
+    free (s);
+  }
+}
+          reply(229, "Entering Extended Passive Mode (|||%d|)",
+              ntohs(port));
+          return;
+      }
+    } else {
+      /* more proper error code? */
+    }
+  
 
   pasv_error:
     (void) close(pdata);
     pdata = -1;
     if (debug) {
-	char *s = calloc(128 + strlen(remoteident), sizeof(char));
+	char *s = calloc(128 + strlen(remotehost), sizeof(char));
 	if (s) {
-	    sprintf(s, "PASV port assignment assigned for %s", remoteident);
+	    sprintf(s, "LPSV/EPSV port assignment assigned for %s", remotehost);
 	    syslog(LOG_DEBUG, "%s", s);
 	    free(s);
 	}
@@ -7027,13 +7517,34 @@
     return rv;
 }
 
+#ifdef INET6
+static struct in6_addr acl_DaemonAddress6(void)
+{
+    struct in6_addr rv = in6addr_any;
+    struct aclmember *entry = NULL;
+
+    if (getaclentry("daemonaddress6", &entry) && ARG0) {
+	    if (inet_pton(AF_INET6, ARG0, &rv))
+		    return rv;
+	    rv = in6addr_any;
+    }
+    return rv;
+}
+#endif
+
+
+
 /* I am running as a standalone daemon (not under inetd) */
 void do_daemon(int argc, char **argv, char **envp)
 {
+#ifdef INET6
+    struct sockaddr_in6 server6;
+    int bind6_success = 0;
+#endif
     struct sockaddr_in server;
     struct servent *serv;
     int pgrp;
-    int lsock;
+    int lsock, lsock6;
     int one = 1;
     FILE *pidfile;
     int i;
@@ -7123,37 +7634,70 @@
 
     syslog(LOG_INFO, "FTP server (%s) ready.", version);
 
+
     /* Create a socket to listen on */
+#ifdef INET6
+    lsock6 = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
+#endif    
     lsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-    if (lsock < 0) {
+    if (lsock < 0 && lsock6 < 0) {
 	syslog(LOG_ERR, "Cannot create socket to listen on: %m");
 	exit(1);
     }
-    if (setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(one)) < 0) {
+
+    if (setsockopt(lsock6, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(one)) < 0 &&
+	setsockopt(lsock, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(one)) < 0 ) {
 	syslog(LOG_ERR, "Cannot set SO_REUSEADDR option: %m");
 	exit(1);
     }
-    if (keepalive)
+
+    if (keepalive){
+#ifdef INET6
+	(void) setsockopt(lsock6, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(one));
+#endif
 	(void) setsockopt(lsock, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(one));
+    }
 
+
+#ifdef INET6
+    server6.sin6_family = AF_INET6;
+    server6.sin6_addr = acl_DaemonAddress6();
+#endif    
     server.sin_family = AF_INET;
     server.sin_addr.s_addr = acl_DaemonAddress();
+
     if (daemon_port == 0) {
 	if (!(serv = getservbyname("ftp", "tcp"))) {
 	    syslog(LOG_ERR, "Cannot find service ftp: %m");
 	    exit(1);
 	}
+#ifdef INET6
+	server6.sin6_port = serv->s_port;
+#endif
 	server.sin_port = serv->s_port;
 	daemon_port = ntohs(serv->s_port);
     }
     else
+#ifdef INET6
+	server6.sin6_port = htons(daemon_port);
+#endif
 	server.sin_port = htons(daemon_port);
 
-    if (bind(lsock, (struct sockaddr *) &server, sizeof(server)) < 0) {
+#ifdef INET6
+    if (bind(lsock6, (struct sockaddr *) &server6, sizeof(server6)) < 0) {
+	syslog(LOG_ERR, "Cannot bind socket: %m");
+	exit(1);
+    }
+    bind6_success = 1;
+#endif
+    if (bind(lsock, (struct sockaddr *) &server, sizeof(server)) < 0 &
+	bind6_success == 0) {
 	syslog(LOG_ERR, "Cannot bind socket: %m");
 	exit(1);
     }
 
+    if (bind6_success == 1)
+	    listen(lsock6, MAX_BACKLOG);
     listen(lsock, MAX_BACKLOG);
 
     sprintf(proctitle, "accepting connections on port %i", daemon_port);
@@ -7162,8 +7706,30 @@
     while (1) {
 	int pid;
 	int msgsock;
+	int sc = -1;
+	fd_set mask;
+
+	FD_ZERO(&mask);
+#ifdef INET6
+	FD_SET(lsock6, &mask);
+#endif
+	FD_SET(lsock, &mask);
+	select(5, &mask, NULL, NULL, NULL);
+
+#ifdef INET6
+	if (FD_ISSET(lsock6, &mask)){
+		sc = lsock6;
+		goto client_accept;
+	}
+#endif
+	if (FD_ISSET(lsock, &mask))
+		sc = lsock;
+
+	if (sc == -1)
+		continue;
 
-	msgsock = accept(lsock, 0, 0);
+    client_accept:
+	msgsock = accept(sc, 0, 0);
 	if (msgsock < 0) {
 	    syslog(LOG_ERR, "Accept failed: %m");
 	    sleep(1);
@@ -7186,8 +7752,13 @@
 	    dup2(msgsock, 0);
 	    dup2(msgsock, 1);
 	    /* Only parent needs lsock */
+#ifdef INET6
+	    if (lsock6 != 0 && lsock6 != 1)
+		close(lsock6);
+#endif
 	    if (lsock != 0 && lsock != 1)
 		close(lsock);
+
 #ifdef FACILITY
 	    openlog("ftpd", LOG_PID | LOG_NDELAY, FACILITY);
 #else
@@ -7293,7 +7864,7 @@
     int which;
     struct aclmember *entry = NULL;
     (void) acl_getclass(class);
-    while (getaclentry("port-allow", &entry)) {
+    while (getaclentry("pasv-allow", &entry)) {
 	if ((ARG0 != NULL) && (strcasecmp(class, ARG0) == 0))
 	    for (which = 1; (which < MAXARGS) && (ARG[which] != NULL); which++) {
 		if (hostmatch(ARG[which], remoteaddr, NULL))
diff -Nur wu-ftpd-2.6.2.orig/support/authuser.c wu-ftpd-2.6.2/support/authuser.c
--- wu-ftpd-2.6.2.orig/support/authuser.c	Sat Jul  1 20:36:28 2000
+++ wu-ftpd-2.6.2/support/authuser.c	Tue Jan 22 20:53:08 2002
@@ -50,6 +50,7 @@
 extern int errno;
 
 #include "authuser.h"
+#include "sa_len.h"
 
 unsigned short auth_tcpport = 113;
 
@@ -69,7 +70,7 @@
 
 static char authline[SIZ];
 
-char *auth_xline(register char *user, register int fd, register long unsigned int *in)
+char *auth_xline(register char *user, register int fd, struct sockaddr *in)
 {
     unsigned short local;
     unsigned short remote;
@@ -77,7 +78,7 @@
 
     if (auth_fd(fd, in, &local, &remote) == -1)
 	return 0;
-    ruser = auth_tcpuser(*in, local, remote);
+    ruser = auth_tcpuser(in, local, remote);
     if (!ruser)
 	return 0;
     if (!user)
@@ -88,28 +89,55 @@
     return authline;
 }
 
-int auth_fd(register int fd, register long unsigned int *in, register short unsigned int *local, register short unsigned int *remote)
+int auth_fd(register int fd, struct sockaddr *in, register short unsigned int *local, register short unsigned int *remote)
 {
-    struct sockaddr_in sa;
+    struct sockaddr_storage su;
 #if defined(UNIXWARE) || defined(AIX)
     size_t dummy;
 #else
     int dummy;
 #endif
 
-    dummy = sizeof(sa);
-    if (getsockname(fd, (struct sockaddr *) &sa, &dummy) == -1)
-	return -1;
-    if (sa.sin_family != AF_INET) {
-	errno = EAFNOSUPPORT;
+    dummy = sizeof(su);
+    if (getsockname(fd, (struct sockaddr *) &su, &dummy) == -1)
 	return -1;
+    switch (su.ss_family) {
+        case AF_INET:
+#ifdef INET6
+	case AF_INET6:
+#endif
+		break;
+	default:
+		errno = EAFNOSUPPORT;
+		return -1;
     }
-    *local = ntohs(sa.sin_port);
-    dummy = sizeof(sa);
-    if (getpeername(fd, (struct sockaddr *) &sa, &dummy) == -1)
-	return -1;
-    *remote = ntohs(sa.sin_port);
-    *in = sa.sin_addr.s_addr;
+    if (local) {
+	    char pbuf[NI_MAXSERV];
+	    getnameinfo((struct sockaddr *)&su, SA_LEN((struct sockaddr *)&su),
+			    NULL, 0, pbuf, sizeof(pbuf), NI_NUMERICSERV);
+	    *local = atoi(pbuf);
+    }
+    dummy = sizeof(su);
+    if (getpeername(fd, (struct sockaddr *)&su, &dummy) == -1)
+	    return -1;
+    switch (su.ss_family) {
+        case AF_INET:
+#ifdef INET6
+	case AF_INET6:
+#endif
+		;
+		break;
+	default:
+		errno = EAFNOSUPPORT;
+		return -1;
+    }
+    if (remote) {
+	    char pbuf[NI_MAXSERV];
+	    getnameinfo((struct sockaddr *)&su, SA_LEN((struct sockaddr *)&su),
+			    NULL, 0, pbuf, sizeof(pbuf), NI_NUMERICSERV);
+	    *remote = atoi(pbuf);
+    }
+    memcpy(in, &su, SA_LEN((struct sockaddr *)&su));
     return 0;
 }
 
@@ -127,16 +155,16 @@
     }
 }
 
-char *auth_tcpuser(register long unsigned int in, register short unsigned int local, register short unsigned int remote)
+char *auth_tcpuser(struct sockaddr *in, register short unsigned int local, register short unsigned int remote)
 {
-    struct sockaddr_in sa;
+    struct sockaddr_storage su;
     register int buflen;
     register int w;
     register int saveerrno;
     char ch;
     unsigned short rlocal;
     unsigned short rremote;
-    extern struct sockaddr_in ctrl_addr;
+    extern struct sockaddr_storage ctrl_addr;
     int on = 1;
 
     buf = realbuf;
@@ -144,19 +172,31 @@
     /* note the reversed order---the example in the RFC is misleading */
     buflen = strlen(buf);
 
-    if ((fdAuth = socket(AF_INET, SOCK_STREAM, 0)) == -1)
+    if ((fdAuth = socket(in->sa_family, SOCK_STREAM, 0)) == -1)
 	return 0;
 
     setsockopt(fdAuth, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));	/*Try */
 
-    sa = ctrl_addr;
-    sa.sin_port = htons(0);
-    bind(fdAuth, (struct sockaddr *) &sa, sizeof(sa));	/* may as well try ... */
-
-    sa.sin_family = AF_INET;
-    sa.sin_port = htons(auth_tcpport);
-    sa.sin_addr.s_addr = in;
-
+    memcpy(&su, &ctrl_addr, SA_LEN((struct sockaddr *)&ctrl_addr));
+    switch(su.ss_family) {
+	    case AF_INET6:
+		    ((struct sockaddr_in6 *)&su)->sin6_port = htons(0);
+		    break;
+	    default:
+		    ((struct sockaddr_in *)&su)->sin_port = htons(0);
+		    break;
+    }
+    bind(fdAuth, (struct sockaddr *)&su, SA_LEN((struct sockaddr *)&su)); /* may
+									as well try ... */
+    memcpy(&su, in, SA_LEN(in));
+    switch(su.ss_family) {
+	    case AF_INET6:
+		    ((struct sockaddr_in6 *)&su)->sin6_port = htons(auth_tcpport);
+		    break;
+	    default:
+		    ((struct sockaddr_in *)&su)->sin_port = htons(auth_tcpport);
+		    break;
+    }
     signal(SIGALRM, timout);
 
 #if defined(LINUX)
@@ -176,7 +216,7 @@
     }
 #endif
     alarm(timeout_rfc931);
-    if (connect(fdAuth, (struct sockaddr *) &sa, sizeof(sa)) == -1) {
+    if (connect(fdAuth, (struct sockaddr *)&su, SA_LEN((struct sockaddr *)&su)) == -1) {
 	saveerrno = errno;
 	alarm(0);
 	if (fdAuth != -1) {
diff -Nur wu-ftpd-2.6.2.orig/support/authuser.h wu-ftpd-2.6.2/support/authuser.h
--- wu-ftpd-2.6.2.orig/support/authuser.h	Sat Jul  1 20:36:28 2000
+++ wu-ftpd-2.6.2/support/authuser.h	Tue Jan 22 20:53:08 2002
@@ -29,9 +29,9 @@
 
 extern unsigned short auth_tcpport;
 
-extern char *auth_xline(register char *user, register int fd, register long unsigned int *in);
+extern char *auth_xline(register char *user, register int fd, struct sockaddr *in);
 
-extern int auth_fd(register int fd, register long unsigned int *in, register short unsigned int *local, register short unsigned int *remote);
+extern int auth_fd(register int fd, struct sockaddr *in, register short unsigned int *local, register short unsigned int *remote);
 
-extern char *auth_tcpuser(register long unsigned int in, register short unsigned int local, register short unsigned int remote);
+extern char *auth_tcpuser(struct sockaddr *in, register short unsigned int local, register short unsigned int remote);
 #endif
diff -Nur wu-ftpd-2.6.2.orig/support/sa_len.h wu-ftpd-2.6.2/support/sa_len.h
--- wu-ftpd-2.6.2.orig/support/sa_len.h	Thu Jan  1 01:00:00 1970
+++ wu-ftpd-2.6.2/support/sa_len.h	Tue Jan 22 20:53:08 2002
@@ -0,0 +1,17 @@
+#if !defined(HAVE_SS_FAMILY_IN_SS) && defined(HAVE___SS_FAMILY_IN_SS)
+#define ss_family __ss_family
+#endif
+
+
+#ifndef SA_LEN
+#ifdef HAVE_SOCKADDR_LEN
+#define	SA_LEN(sa)	((sa)->sa_len)
+#else
+#ifdef INET6
+#define SA_LEN(sa)	((sa)->sa_family == AF_INET6 ? sizeof(struct sockaddr_in6) :	\
+			((sa)->sa_family == AF_INET  ? sizeof(struct sockaddr_in)  : 0))
+#else
+#define SA_LEN(sa)	((sa)->sa_family == AF_INET ? sizeof(struct sockaddr_in) : 0)
+#endif
+#endif
+#endif /* SA_LEN */
